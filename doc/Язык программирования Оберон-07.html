<!DOCTYPE html>
<!-- saved from url=(0037)https://models.molpit.org/oberon.html -->
<html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<title>Язык программирования Оберон-07</title>
	<style>
	pre { font-size: 10pt;}
	ol { counter-reset: item; padding-left: 15px;}
	ol>li { display: block; margin: 5px; }
	ol>li:before { content: counters(item, ".") ". "; counter-increment: item }

	</style>
</head>
<body style="margin: 5%; max-width: 1000px; text-align: justify; font-family: Arial;">

<a href="https://models.molpit.org/">← Модели Онлайн</a><br><br>

<a href="https://www.inf.ethz.ch/personal/wirth/Oberon/Oberon07.Report.pdf">Оригинал объявления о языке</a>

<h1>Язык программирования Оберон</h1>
<p>Ревизия 1.10.2013 / 3.5.2016</p>
<p>Никлаус Вирт</p>
<p><i>Упрощай до тех пор, пока это возможно, но не более того. (А. Эйнштейн)</i></p>

<h4>Содержание</h4>
<ol>
<li><a href="https://models.molpit.org/oberon.html#sec1">История и введение</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec2">Синтаксис</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec3">Словарь</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec4">Объявления и область действия</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec5">Объявление констант</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec6">Объявление типов</a><ol>
<li><a href="https://models.molpit.org/oberon.html#sec61">Базовые типы</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec62">Тип массив</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec63">Тип запись</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec64">Тип указатель</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec65">Процедурный тип</a></li></ol>
</li><li><a href="https://models.molpit.org/oberon.html#sec7">Объявление переменных</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec8">Выражения</a><ol>
<li><a href="https://models.molpit.org/oberon.html#sec81">Операнды</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec82">Операторы</a></li></ol>
</li><li><a href="https://models.molpit.org/oberon.html#sec9">Операторы</a><ol>
<li><a href="https://models.molpit.org/oberon.html#sec91">Присваивания</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec92">Вызовы процедур</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec93">Последовательность операторов</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec94">Операторы If</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec95">Операторы Case</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec96">Операторы While</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec97">Операторы Repeat</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec98">Операторы For</a></li></ol>
</li><li><a href="https://models.molpit.org/oberon.html#sec10">Объявление процедур</a><ol>
<li><a href="https://models.molpit.org/oberon.html#sec101">Формальные параметры</a>
</li><li><a href="https://models.molpit.org/oberon.html#sec102">Процедуры, связанные с типом</a></li></ol>
</li><li><a href="https://models.molpit.org/oberon.html#sec11">Модули</a><ol>
<li><a href="https://models.molpit.org/oberon.html#sec111">Модуль SYSTEM</a></li></ol>

</li></ol>

<a href="https://models.molpit.org/oberon.html#appendix">Приложение: Синтаксис Оберона</a>


<h2><a name="sec1">1. История и введение</a></h2>

<p>Оберон — язык программирования общего назначения эволюционировавший 
из Модулы-2. Его принципиальная новая особенность — концепция расширения
 типов. Он позволяет конструировать новые типы данных на основе 
существующих и устанавливать между ними отношения.</p>

<p>Этот документ не является учебником программирования. Он 
преднамеренно краток. Его назначение — служить эталоном для 
программистов, разработчиков компиляторов и авторов руководств. Если о 
чем-то не сказано, то обычно сознательно: или потому, что это следует из
 других правил языка, или потому, что это может нежелательно ограничить 
свободу разработчикам компиляторов.</p>

<p>Этот документ описывает язык определенный в 1988/90 и пересмотренный в 2007 / 2016.</p>

<h2><a name="sec2">2. Синтаксис</a></h2>

<p>Язык представляет собой бесконечное множество предложений, а именно 
предложений хорошо сформированных в соответствии с его синтаксисом. В 
Обероне эти предложения называются единицами компиляции. Каждая единица 
представляет собой конечную последовательность <i>символов</i> из 
конечного словаря. Словарь Оберона состоит из идентификаторов, чисел, 
строк, операторов, разделителей и комментариев. Они называются <i>лексическими символами</i> и состоят из последовательностей <i>литер</i>. (Обратите внимание на разницу между символами и литерами.)</p>

<p>Для описания синтаксиса используются расширенный форализм Бэкуса — 
Наура (расширенная Бэкус — Наурова форма (РБНФ)). Квадратные скобки [ и ]
 означают необязательность записанного внутри них выражения, а фигурные 
скобки { и } означают его повторение (возможно 0 раз). Синтаксические 
единицы (нетерминальные символы) обозначаются английскими словами, 
выражающими их интуитивное назначение. Символы словаря языка 
программирования (терминальные символы) обозначаются строками, 
заключенными в кавычки или заглавными буквами.</p>

<h2><a name="sec3">3. Словарь</a></h2>

<p>Для составления терминальных символов предусматривается использование
 следующих правил. Пробелы и переносы не должны встречаться внутри 
символов (исключая комментарии и пробелы в строках). Они игнорируются, 
если они не существенны для отделения двух последовательных символов. 
Заглавные и строчные буквы считаются различными.</p>

<p><i>Идентификаторы</i> — последовательности букв и цифр. Первая литера должен быть буквой.</p>
<pre>	идент = буква {буква | цифра}.
</pre>
<p>Примеры:</p>
<pre>	x  Scan  Oberon  GetSymbol  firstLetter
</pre>
<p><i>Числа</i> — (беззнаковые) целые или вещественные числа. Целые 
являеются последовательностью цифр и могуть быть продолжены буквой 
суффикса. Если суффикса нет, то представление десятичное. Суффикс H 
обозначает шестнадцатеричное представление.</p>

<p><i>Вещественное число</i> всегда содержит десятичную точку. 
Опционально оно может также содержать десятичный порядок. Буква E 
означает «умножить на десять в степени».</p>
<pre>	число		=  целое | вещественное.
	целое		=  цифра {цифра} | цифра {шестнЦифра} "H".
	вещественное	=  цифра {цифра} "." {цифра} [Порядок].
	Порядок		=  ("E") ["+" | "-"] цифра {цифра}.
	шестнЦифра	=  цифра | "A" | "B" | "C" | "D" | "E" | "F".
	цифра		=  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9".
</pre>

<p>Примеры:</p>
<pre>	1987
	100H	= 256
	12.3
	4.567E8 = 456700000
</pre>

<p><i>Строки</i> — последовательность литер, заключенных в двойные 
кавычки ("). Ограничивающая кавычка не должна встречаться внутри строки.
 Альтернативно, строка из одной литеры может быть определена порядковым 
номером буквы в шестнадцетеричной нотации с последующей литерой "X". 
Число литер в строке называется <i>длиной</i> строки.</p>
<pre>	строка = """ {символ} """ | цифра {шестнЦифра} "X".
</pre>
<p>Примеры:</p>
<pre>	"OBERON"    "Don't worry!"    22X
</pre>

<p><i>Операторы</i> и <i>разделители</i> — это специальные литеры, пары 
литер или зарезервированные слова, перечисленные ниже. Зарезервированные
 слова состоят исключительно из заглавных букв и не могут использоваться
 в качестве идентификаторов.
</p><pre>	+	:=	ARRAY	IMPORT	THEN
	-	^	BEGIN	IN	TO
	*	=	BY	IS	TRUE
	/	#	CASE	MOD	TYPE
	~	&lt;	CONST	MODULE	UNTIL
	&amp;	&gt;	DIV	NIL	VAR
	.	&lt;=	DO	OF	WHILE
	,	&gt;=	ELSE	OR
	;	..	ELSIF	POINTER
	|	:	END	PROCEDURE
	(	)	FALSE	RECORD
	[	]	FOR	REPEAT
	{	}	IF	RETURN 	
</pre>

<p><i>Комментарии</i> могут быть вставлены между любыми двумя символами в
 программе. Они являются произвольными последовательностями литер, 
которые открываются скобкой (* и закрываются с помощью *). Комментарии 
не влияют на смысл программы. Они могут быть вложенными.</p>


<h2><a name="sec4">4. Объявления и область действия</a></h2>

<p>Каждый встречающийся в программе идентификатор должен быть объявлен, 
если это не стандартный идентификатор. Объявления также служат для 
задания определенных постоянных свойств объекта, например, является ли 
он константой, типом, переменной или процедурой.</p>

<p>Идентификатор используется для ссылки на соответствующий объект. Это 
возможно в тех частях программы, которые находятся в пределах области 
объявления. Идентификатор не может обозначать больше чем один объект 
внутри данной области. Область распространяется текстуально от точки 
объявления до конца блока (процедуры или модуля), к которому принадлежит
 объявление и, следовательно, к которому объект является локальным.</p>

<p>Идентификатор, объявленный в блоке модуля, может сопровождаться 
экспортной меткой (*), чтобы указать, что он экспортируется из 
определяющего модуля. В этом случае идентификатор может быть использован
 и в других модулях, если они импортируют объявляющий модуль. 
Идентификатор затем предваряется идентификатором, обозначающим его 
модуль (см. Гл 11). Префикс и идентификатор разделены точкой и вместе 
называются уточненным идентификатором.</p>

<pre>	УточнИдент	=  [идент "."] идент.
	ИдентОпр	=  идент ["*" | "-"].
</pre>

Следующие идентификаторы являются стандартными; их значение определено в разделе 6.1 (типы) и 10.2 (процедуры): 

<pre>	ABS	ASR	ASSERT	BOOLEAN	BYTE
	CHAR	CHR	DEC	EXCL	FLOOR
	FLT	INC	INCL	INTEGER	LEN	
	LSL	NEW	ODD	ORD	PACK
	REAL	ROR	SET	UNPK
</pre>

<h2><a name="sec5">5. Объявление констант</a></h2>

<p>Объявление константы связывает ее идентификатор с ее значением.</p>

<pre>	ОбъявлениеКонстанты	= ИдентОпр "=" КонстантноеВыражение.
	КонстантноеВыражение	= Выражение.
</pre>

<p>Константное выражение может быть вычислено по его тексту без 
фактического выполнения программы. Его операнды — константы (см. Гл. 8).
 Примеры объявлений констант:</p>

<pre>	N = 100
	limit = 2*N - 1
	all = {0 .. WordSize-1}
	name = "Oberon"
</pre>


<h2><a name="sec6">6. Объявление типов</a></h2>

<p>Тип данных определяет множество значений, которые переменные этого 
типа могут принимать и операторов, которые применимы. Объявление типа 
используется для связывания идентификатора с типом. Типы определяют 
структуру переменных этого типа и, косвенно, операторы, которые 
применимы к компонентам. Есть две разные структуры данных, а именно 
массивы и записи, с различным способом выбора компонентов.</p>

<pre>	ОбъявлениеТипа = ИдентОпр "=" Тип.
	Тип = УточнИдент | ТипМассив | ТипЗапись | ТипУказатель | ПроцедурныйТип.
</pre>

<p>Примеры:</p>

<pre>	Table = ARRAY N OF REAL
	Tree = POINTER TO Node
	Node = RECORD
		key : INTEGER;
		left, right: Tree
	END
	CenterTree = POINTER TO CenterNode
	CenterNode = RECORD (Node)
		name: ARRAY 32 OF CHAR;
		subnode: Tree
	END
	Function = PROCEDURE (x: INTEGER): INTEGER
</pre>

<h3><a name="sec61">6.1 Базовые типы</a></h3>
<p>
Следующие предопределенные типы обозначаются заранее объявленными идентификаторами.
Связанные операторы определены в 8.2, а предварительно объявляенные функции - в 10.2.
Значения заданного базового типа следующие:
</p><pre>	BOOLEAN -- принимает значения TRUE и FALSE
	CHAR - символы стандартного набора символов.
	INTEGER - целые числа
	REAL -- Действительные числа 
	BYTE -- целые числа от 0 до 255
	SET -- набор целых чисел между 0 и пределом, зависящим от реализации
</pre>
Тип BYTE совместим с типом INTEGER, и наоборот.<p></p>

<h3><a name="sec62">6.2 Тип массив</a></h3>
<p>
Массив - это структура, состоящая из фиксированного числа элементов одного типа,
 называемого типом элемента. Число элементов массива называется его длиной. 
 Элементы массива обозначаются индексами, которые являются целыми числами 
 от 0 до длины минус 1. 
</p><pre>	ArrayType = ARRAY {"," длина} OF тип_элемента. 
	длина = ConstExpression.
</pre>
Форма объявления
<pre>	ARRAY N0, N1, ..., Nk OF T
</pre>
понимается как аббревиатура декларации
<pre>	ARRAY N0 OF 
		ARRAY N1 OF
		...
			ARRAY Nk OF  T
</pre>
Примеры типов массивов:
<pre>	ARRAY N OF INTEGER 
	ARRAY 10, 20 OF REAL 
</pre>
<p></p>
<h3><a name="sec63">6.3 Тип запись</a></h3>
<p>
Тип записи - это структура, состоящая из фиксированного числа элементов 
возможно разных типов. Объявление типа записи задаёт для каждого элемента, 
которое называется полем, его тип и идентификатор, который обозначает 
это поле. Область действия этих идентификаторов полей - само 
определение записи, но они также видны как части экземпляра записи 
в форме "через точку" (см. 8.1), которая ссылается на элементы 
самого экземпляра записи.
</p><pre>	RecordType = RECORD ["(" BaseType ")"] [FieldListSequence] END.
	BaseType = qualident.
	FieldListSequence = FieldList {";" СписокПолей}.
	СписокПолей = IdentList ":" тип.
	IdentList = identdef {"," identdef}.
</pre>
Если тип записи экспортируется, идентификаторы полей, которые должны быть видимыми вне модуля объявления, должны быть помечены. Они называются публичными полями; Немаркированные поля называются приватными полями.
Типы записей являются расширяемыми, т. е. тип записи может быть определён как расширение другого типа записи. В приведенных выше примерах CenterNode (непосредственно) расширяет Node, который является (прямым) базовым типом CenterNode. Более конкретно, CenterNode расширяет Node с именем поля и подузлом.
Определение. Тип T расширяет тип T0, если он равен T0, или если он непосредственно расширяет расширение T0.
И наоборот, тип T0 является базовым типом для типа T, если он равен T, или если он является прямым базовым типом базового типа T.

Примеры типов записей:
<pre>	RECORD день, месяц, год: INTEGER
	END 
	RECORD
	  name, firstname: ARRAY 32 OF CHAR;
	  Возраст: INTEGER;
	  зарплата: REAL
	END
</pre><p></p>
<h3><a name="sec64">6.4 Тип указатель</a></h3>
<p>
Переменные указателя типа P принимают в качестве значений указатели на 
переменные некоторого типа T. Этот тип должен быть типом записи. Указатель 
типа P называется связанным с T, а T - базовым типом указателя P. 
Типы указателей наследуют отношение расширения их базовых типов, если они есть. 
Если тип T является расширением T0 и P является типом указателя, связанным с 
T, то P также является расширением P0, тип указателя, связанный с T0.
</p><pre>	PointerType = POINTER TO тип .
</pre>
Если тип P определён как POINTER TO T, идентификатор T может быть текстуально 
объявлен после объявления P, но [если это так] он должен находиться в 
пределах одной области.
Если p - переменная типа P = POINTER TO T, то вызов предопределённой 
процедуры NEW (p) имеет следующий эффект (см. 10.2): переменная типа T 
выделяется в свободном хранилище, а указатель на нее присваивается p. 
Этот указатель p имеет тип P, а ссылочная переменная p ^ имеет тип T. 
Отказ распределения памяти под структуры приводит к тому, что p получает 
значение NIL. Каждой переменной-указателю может быть присвоено значение 
NIL, которое вообще не указывает на переменную.
<p></p>
<h3><a name="sec65">6.5 Процедурный тип</a></h3>
<p>
Переменные процедурного типа T имеют процедуру (или NIL) в качестве 
значения. Если процедуре P присвоена переменная процедурного типа T, 
формальные параметры (типа) P должны быть такими же, как те, что указаны
 в формальных параметрах T. То же самое справедливо для типа результата 
 в случае (См. 10.1). P не должен быть объявлен локальным для другой 
 процедуры, и не может быть стандартной процедурой.
 </p><pre>	ProcedureType = PROCEDURE [FormalParameters].
</pre>
<p></p>
<h2><a name="sec7">7. Объявление переменных</a></h2>

<p>
Объявления переменных служат для введения переменных и связывания их с 
идентификаторами, которые должны быть уникальными в пределах данной 
области. Они также служат для связывания фиксированных типов данных с 
переменными. VariableDeclaration = IdentList ":" type. Переменные, 
идентификаторы которых отображаются в одном списке, имеют один и тот же 
тип. Примеры деклараций переменных (см. Примеры в главе 6):
</p><pre>	i, j, k: INTEGER
	x, y: REAL
	p, q: BOOLEAN
	s: SET f: Function
	a: ARRAY 100 OF REAL 
	w: ARRAY 16 OF 
		RECORD
			ch: CHAR; 
			count: INTEGER 
		END 
	t:  Tree 
</pre>
<p></p>

<h2><a name="sec8">8. Выражения</a></h2>

<p>
Выражения - это конструкции, обозначающие правила вычисления, в которых 
константы и текущие значения переменных объединяются для получения других 
значений посредством применения операторов и функциональных процедур. 
Выражения состоят из операндов и операторов. Круглые скобки могут использоваться 
для выражения определенных ассоциаций операторов и операндов.
</p>

<h3><a name="sec81">8.1 Операнды</a></h3>
<p>За исключением наборов и литеральных констант, то есть чисел и строк, 
операнды обозначаются "указателями". Обозначение состоит из идентификатора, 
относящегося к константе, переменной или процедуре, которая будет обозначена. 
Такой идентификатор может быть определён идентификатор модуля 
(см. Главы 4 и 11), и за ним могут следовать селекторы,
 если назначенный объект является элементом структуры.
 </p><p>
 Если A обозначает массив, то A [E] обозначает тот элемент A, индекс 
 которого является текущим значением выражения E. Тип E должен иметь тип 
 INTEGER. Обозначение вида A [E1, E2, ..., En] обозначает 
 A [E1] [E2] ... [En]. Если p обозначает переменную-указатель, p^ 
 обозначает переменную, на которую ссылается p. Если r обозначает запись, 
 то r.f обозначает поле f из записи r. Если p обозначает указатель, 
 p.f обозначает поле f записи p ^, то есть точка подразумевает 
 разыменование, а p.f означает p^.f.
 </p>
 <p>
 Охрана типа v(Т0) проверяет, что v имеет тип T0, то есть защита типа 
 прекращает выполнение программы, если v не типа T0. Охранник применим, 
 если
 </p><pre>  1. T0 является расширением объявленного типа T в v, и если 
  2. v - переменный параметр типа записи, или v - указатель. 
 
	указатель = квалификатор {селектор}
	селектор= "." Идентификация | "[" ExpList "]" | «^» | "(" Qualident ")"
	ExpList = выражение {"," выражение}.
 </pre>
 <p></p>
 <p>
Если назначенный объект является переменной, то обозначение ссылается на
текущее значение переменной. Если объект является процедурой, указатель 
без списка параметров ссылается на эту процедуру. Если за ним следует 
список параметров (возможно, пустой), указатель подразумевает активацию 
процедуры и обозначает значение, полученное в результате его выполнения. 
Действительные параметры (используемых типов) должны соответствовать 
формальным параметрам, указанным в объявлении процедуры (см. Главу 10).
</p>
<p>

Примеры обозначений (см. Примеры в главе 7):
</p><pre>	i			(INTEGER)
	а[I]			(REAL)
	w[3].ch			(CHAR)
	t.key			(INTEGER)
	t.left.right 		(Дерево)
	t(CenterNode).subnode	(Дерево)
</pre>
 <p></p>
<h3><a name="sec82">8.2 Операторы</a></h3>
<p>
Синтаксис выражений различает четыре класса операторов с разными 
приоритетами (сильные связи). Оператор ~ имеет наивысший приоритет, 
за которым следуют операторы умножения, сложения и отношения. 
Операторы одного и того же приоритета ассоциируются слева направо. 
Например, x-y-z означает (x-y) -z.
</p><pre>	выражение = SimpleExpression [отношение SimpleExpression].
	отношение  =  "=" | "#" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | IN | IS. 
	SimpleExpression  =  ["+"|"−"] term {AddOperator term}. 
	AddOperator  =  "+" | "−" | OR. 
	term  =  factor {MulOperator factor}. 
	MulOperator  =  "*" | "/" | DIV | MOD | "&amp;" . 
	factor  =  number | string | NIL | TRUE | FALSE | set | designator [ActualParameters] | "(" выражение ")" | "~" factor. 
	set  =  "{" [element {"," element}] "}". 
	element  =  выражение [".." выражение]. 
	ActualParameters  =  "(" [ExpList] ")" . 
</pre>
<p></p>
<p>
Множество {m..n} обозначает {m, m + 1, ..., n-1, n}, а если m&gt; n, то 
пустое множество. Доступные операторы перечислены в следующих таблицах. 
В некоторых случаях несколько разных операций обозначаются одним и тем 
же символом оператора. В этих случаях фактическая операция определяется 
типом операндов.
</p>
<h4><a name="sec821">8.2.1 Логические операторы</a></h4>
<p>
</p><pre>	Символ	Результат
	OR	логическая дизъюнкция
	&amp; 	логическое соединение
	~ 	логическое отрицание
</pre>

Эти операторы применяются к операндам BOOLEAN и дают результат BOOLEAN.
<pre>	р OR q	означает «если р, то TRUE, иначе q»
	p &amp; q	обозначает «если р, то q, иначе FALSE»
	~ P	означает "не p"

</pre>
<p></p>
<h4><a name="sec822">8.2.2 Арифметические операторы</a></h4>
<p>
</p><pre>	Символ	Результат
	+	сумма
	-	разница
	*	умножение
	/	деление
	DIV	целое частное
	MOD	модуль
</pre>
Операторы +, -, * и / применяются к операндам числовых типов. Оба операнда
должны быть одного типа, что также определяет тип результата. При 
использовании в качестве унарных операторов "-" обозначает инверсию знака, 
а "+" обозначает операцию <b>идентичности</b>. Операторы DIV и MOD применяются 
только к целочисленным операндам. Пусть q = x DIV y и r = x MOD y. 
Тогда <b>фактор</b> q и остаток r определяются уравнением
<pre>	X = q * y + r 		0 &lt;= r &lt; y
</pre>

<p></p>

<h4><a name="sec823">8.2.3 Операторы наборов</a></h4>
<p>
</p><pre>	Символ	Результат
	+	объединение 
	-	разница 
	*	пересечение 
	/	cимметричная разность наборов 
</pre>
<i>
Вот вообще явный переводной спор.<br>
1. SET -- это буквально НАБОР. Т.е. что-то имеющее ограничение<br>
2. SET -- это также "установить". Т.е. какое-то действие, что вводит в заблуждение <br>
3. "Множество" -- это буквально "много чего-то", непончтно сколько, непонятны границы.<br><br>
</i>
Когда используется с одним операндом типа SET, знак минус обозначает 
дополнение набора.
<p></p>
<h4><a name="sec823">8.2.4 Отношения</a></h4>
<p>
</p><pre>	Символ	Отношение
	=	равно 
	#	неравно 
	&lt;	меньше 
	&lt;=	меньше или равно 
	&gt;	больше 
	=	больше или равно 
	IN	членство в наборе 
	IS	проверка типа
</pre>
Булевы отношения. Отношение упорядочения &lt;, &lt;=,&gt;,&gt; = применяется к 
числовым типам, CHAR и символьным массивам. Отношения = и # применимы 
также к типам BOOLEAN, SET, указателям и процедурным типам.
<p></p>
<p>
x IN s обозначает "x является элементом s". x должен иметь тип INTEGER и
s должен быть типом SET. v IS T означает «v имеет тип T» и 
вызывает проверку типа. Это применимо, если 
</p><pre>	1. T - расширение объявленного типа T0 для v, и если 
	2. v - переменный параметр типа записи или v - указатель. 
</pre>
Предполагая, например, что T является 
расширением T0 и что v является указателем на тип T0, тогда проверка
v IS T определяет, является ли фактически назначенная переменная 
(не только T0, но и также) типом T. Значение NIL IS T не определено.
<p></p>
<p>
Примеры выражений (см. Примеры в главе 7):
</p><pre>	1987			(INTEGER)
	I DIV 3			(INTEGER)
	~ P OR q		(BOOLEAN)
	(I + j) * (i-j)		(INTEGER)
	S - {8, 9, 13}		(SET)
	A [i + j] * a [i-j]	(REAL)
	(0 &lt;= i) &amp; (i &lt;100)	(BOOLEAN)
	T.key = 0		(BOOLEAN)
	K IN {i .. j-1}		(BOOLEAN)
	T IS CenterNode		(BOOLEAN)
</pre>
<p></p>
<h2><a name="sec9">9. Операторы</a></h2>
<p>
Операторы отвечают за действия. Есть элементарные и структурированные 
операторы. Элементарные операторы не состоят из каких-либо частей, 
которые сами являлись бы операторами. Они выражаются в присваивании и вызове 
процедуры. Структурированные операторы состоят из частей, которые сами 
являются операторами. Они используются, чтобы выразить последовательное 
и условное, выборочное и повторное исполнение. Операторы также могут 
быть пустыми, и в этом случае они не означают никаких действий. Пустой 
оператор включен для того, чтобы ослабить правила пунктуации в 
последовательностях операторов.
</p><pre>	оператор  =  [Присвоение | ВызовПроцедур | Оператор_IF | Оператор_CASE | Оператор_WHILE | Оператор_REPEAT | Оператор_FOR]. 
</pre>
<p></p>
<h3><a name="sec91">9.1 Присваивания</a></h3>
<p>
Присвоение служит для замены текущего значения переменной на новое 
значение, заданное выражением. Оператор присваивания записывается 
как «: =» и произносится как «становится».
</p><pre>	присвоение  =  переменная ":=" выражение.
</pre>
Если значение параметра структурировано (имеет тип массива или тип 
записи), никакого присваивания ему или его элементов не допускаются. 
Импортированные переменные также не могут присваиваться.
<p></p>
<p>
Тип выражения должен быть таким же, как у переменной. Имеют место 
следующие исключения:
</p><pre>	1. Константу NIL можно присвоить переменным любого типа указателя или процедуры.
	2. Строки могут быть назначены любому массиву символов, если количество 
		символов в строке меньше, чем количество символов в массиве. (Добавляется нулевой символ). 
		Односимвольные строки также могут быть присвоены переменным типа CHAR.
	3. В случае записей тип источника должен быть расширением типа адресата.
	4. Открытый массив может быть назначен массиву равного базового типа.
</pre>
Примеры присвоений (см. Примеры в главе 7):
<pre>	i := 0 
	p := i = j 
	x := FLT(i + 1) 
	k := (i + j) DIV 2 
	f := log2 
	s := {2, 3, 5, 7, 11, 13} 
	a[i] := (x+y) * (x-y) 
	t.key := i 
	w[i+1].ch := "A" 
</pre>
<p></p>
<h3><a name="sec92">9.2 Вызовы процедур</a></h3>
<p>
Вызов процедуры служит для активации процедуры. Вызов процедуры может 
содержать список фактических параметров, которые заменяются вместо 
соответствующих формальных параметров, определенных в объявлении 
процедуры (см. Главу 10). Соответствие устанавливается положениями 
параметров в списках фактических и формальных параметров соответственно. 
Существуют два вида параметров: переменные и значения.
</p>
<p>
В случае переменных параметров фактический параметр должен быть 
обозначением, обозначающим переменную. Если он обозначает элемент 
структурной переменной, селектор вычисляется, когда фактическая 
формальная замена / параметр имеет место, то есть перед выполнением 
процедуры. Если параметр является параметром значения, соответствующий 
фактический параметр должен быть выражением. Это выражение вычисляется 
до активации процедуры, и результирующее значение присваивается 
формальному параметру, который теперь представляет собой локальную 
переменную (см. Также 10.1.).
</p><pre>	Вызов_Процедуры  =  Переменная [Актуальные_Параметры]. 
</pre>
Примеры вызова процедур:
<pre>	ReadInt(i)		(см. Главу 10) 
	WriteInt(2*j + 1, 6) 
	INC(w[k].count) 
</pre>
<p></p>
<h3><a name="sec93">9.3 Последовательность операторов</a></h3>
<p>
Последовательности операторов обозначают последовательность действий, 
заданную компонентами оператора, разделенную точкой с запятой.
</p><pre>	Последовательность_Операторов  =  Оператор {";" Оператор}. 
</pre>
<p></p>
<h3><a name="sec94">9.4 Оператор IF</a></h3>
<p>
</p><pre>	Оператор_IF  =  IF выражение THEN
		Последовательность_Операторов 
	{ELSIF выражение THEN
		Последовательность_Операторов} 
	[ELSE
		Последовательность_Операторов] 
	END.
 </pre>
<p></p>
<p>
Операторы IF определяют условное выполнение охраны операторов. 
Логическое выражение, предшествующее оператору называется охрана. 
Охрана оценивает выражение в порядке возникновения, пока выражение имеет 
значение TRUE, после чего выполняется связанная с охраной последовательность 
операторов. Если охраны не выполнена, то выполняется последовательность 
операторов после символа ELSE, если такая ветка существует. Пример:
</p><pre>	IF (литера &gt;= "A") &amp; (литера &lt;= "Z") THEN
		Сущность_Читать 
	ELSIF (литера &gt;= "0") &amp; (литера &lt;= "9") THEN
		Число_Читать 
	ELSIF литера = 22X THEN 
		Строку_Читать 
	END 
</pre>
<p></p>
<h3><a name="sec95">9.5 Операторы Case</a></h3>
<h3><a name="sec96">9.6 Операторы While</a></h3>
<h3><a name="sec97">9.7 Операторы Repeat</a></h3>
<h3><a name="sec98">9.8 Операторы For</a></h3>

<h2><a name="sec10">10. Объявление процедур</a></h2>

<p></p>
<h3><a name="sec101">10.1 Формальные параметры</a></h3>
<h3><a name="sec102">10.2 Процедуры, связанные с типом</a></h3>

<h2><a name="sec11">11. Модули</a></h2>
<h3><a name="sec111">11.1 Модуль SYSTEM</a></h3>

<p></p>

<h2><a name="appendix">Приложение: Синтаксис Оберона</a></h2>

letter  =  "A" | "B" | ... | "Z" | "a" | "b" | ... | "z".<br>
digit  =   "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9".<br>
hexDigit  =  digit | "A" | "B" | "C" | "D" | "E" | "F".<br><br>

ident  =  letter {letter | digit}.<br>
qualident  =  [ident "."] ident.<br>
identdef = ident ["*"].<br><br>

integer  =  digit {digit} | digit {hexDigit} "H".<br>
real  =  digit {digit} "." {digit} [ScaleFactor].<br>
ScaleFactor  =  "E" ["+" | "-"] digit {digit}.<br>
number  =  integer | real.<br>
string  =  """ {character} """ | digit {hexDigit} "X".<br><br>

ConstDeclaration  =  identdef "=" ConstExpression.<br>
ConstExpression  =  expression.<br><br>

TypeDeclaration  =  identdef "=" type.<br>
type  =  qualident | ArrayType | Record<br>
Type | PointerType | ProcedureType.<br>
ArrayType  =  ARRAY length {"," length} OF type.<br>
length  =  ConstExpression.<br>
RecordType  =  RECORD ["(" BaseType ")"] [FieldListSequence] END.<br>
BaseType  =  qualident.<br>
FieldListSequence  =  FieldList {";" FieldList}.<br>
FieldList  =  IdentList ":" type.<br>
IdentList  =  identdef {"," identdef}.<br>
PointerType  =  POINTER TO type.<br>
ProcedureType  =  PROCEDURE [FormalParameters].<br><br>

VariableDeclaration  =  IdentList ":" type.<br><br>

expression  =  SimpleExpression [relation SimpleExpression].<br>
relation  =  "=" | "#" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | IN | IS.<br>
SimpleExpression  =  ["+" | "-"] term {AddOperator term}.<br>
AddOperator  =  "+" | "-" | OR.<br>
term  =  factor {MulOperator factor}.<br>
MulOperator  =  "*" | "/" | DIV | MOD | "&amp;".<br>
factor  =  number | string | NIL | TRUE | FALSE | set | designator [ActualParameters] | "(" expression ")" | "~" factor.<br>
designator  =  qualident {selector}.<br>
selector  =  "." ident | "[" ExpList "]" | "^" |  "(" qualident ")". <br>
set  =  "{" [element {"," element}] "}". <br>
element  =  expression [".." expression]. <br>
ExpList  =  expression {"," expression}. <br>
ActualParameters  =  "(" [ExpList] ")" . <br><br>

statement  =  [assignment | ProcedureCall | IfStatement | CaseStatement | WhileStatement | RepeatStatement | ForStatement]. <br>
assignment  =  designator ":=" expression. <br>
ProcedureCall  =  designator [ActualParameters]. <br>
StatementSequence  =  statement {";" statement}. <br>
IfStatement  =  IF expression THEN StatementSequence <br>
&nbsp;&nbsp;{ELSIF expression THEN StatementSequence} <br>
&nbsp;&nbsp;[ELSE StatementSequence] END. <br>
CaseStatement  =  CASE expression OF case {"|" case} END. <br>
case  =  [CaseLabelList ":"  StatementSequence]. <br>
CaseLabelList  = LabelRange {"," LabelRange}. <br>
LabelRange  =  label [".." label]. <br>
label  =  integer | string | qualident. <br>
WhileStatement  =  WHILE expression DO StatementSequence <br>
&nbsp;&nbsp;{ELSIF expression DO StatementSequence} END. <br>
RepeatStatement  =  REPEAT StatementSequence UNTIL expression. <br>
ForStatement  =  FOR ident ":=" expression TO expression [BY ConstExpression]<br>
&nbsp;&nbsp;DO StatementSequence END. <br><br>

ProcedureDeclaration  =  ProcedureHeading ";" ProcedureBody ident.<br>
ProcedureHeading  =  PROCEDURE identdef [FormalParameters]. <br>
ProcedureBody  =  DeclarationSequence [BEGIN StatementSequence] <br>
&nbsp;&nbsp;[RETURN expression] END. <br>
DeclarationSequence  =  [CONST {ConstDeclaration ";"}] <br>
&nbsp;&nbsp;[TYPE {TypeDeclaration ";"}] <br>
&nbsp;&nbsp;[VAR   {VariableDeclaration   ";"}]<br>
&nbsp;&nbsp;{ProcedureDeclaration   ";"}.<br>
FormalParameters  =  "(" [FPSection {";" FPSection}] ")" [":" qualident]. <br>
FPSection  =  [VAR] ident {"," ident} ":" FormalType. <br>
FormalType  =  {ARRAY OF} qualident. <br><br>

module  =  MODULE ident ";" [ImportList] DeclarationSequence <br>
&nbsp;&nbsp;[BEGIN StatementSequence] END ident "." .<br> 
ImportList  =  IMPORT import {"," import} ";". <br>
import = ident [":=" ident].<br>


<div style="float: right;">Перевод выполнили Иван Денисов и Валерий Шипков. Использован <a href="http://www.uni-vologda.ac.ru/oberon/o2rus.htm">перевод С.Свердлова</a>.</div>




</body></html>